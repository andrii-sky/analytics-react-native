{"version":3,"sources":["SegmentDestination.ts"],"names":["DestinationPlugin","PluginType","chunk","sendEvents","MAX_EVENTS_PER_BATCH","SegmentDestination","destination","update","_","__","execute","event","pluginSettings","analytics","settings","get","plugins","getPlugins","deviceModePlugins","map","plugin","key","cloudSettings","mergedEvent","integrations","queueEvent","flush","events","chunkedEvents","getConfig","maxBatchSize","sentEvents","numFailedEvents","Promise","all","batch","config","concat","e","console","warn","length","removeEvents","debug","info","error"],"mappings":";;AAAA,SAASA,iBAAT,QAAkC,WAAlC;AACA,SACEC,UADF,QAMO,UANP;AAOA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,UAAT,QAA2B,QAA3B;AAEA,MAAMC,oBAAoB,GAAG,GAA7B;AAEA,OAAO,MAAMC,kBAAN,SAAiCL,iBAAjC,CAAmD;AAAA;AAAA;;AAAA,kCACjDC,UAAU,CAACK,WADsC;;AAAA,iCAGlD,YAHkD;AAAA;;AAKxDC,EAAAA,MAAM,CAACC,CAAD,EAAwBC,EAAxB,EAAwC,CAC5C;AACA;AACA;AACD;;AAEDC,EAAAA,OAAO,CAACC,KAAD,EAAoC;AAAA;;AACzC,UAAMC,cAAc,sBAAG,KAAKC,SAAR,oDAAG,gBAAgBC,QAAhB,CAAyBC,GAAzB,EAAvB;AACA,UAAMC,OAAO,uBAAG,KAAKH,SAAR,qDAAG,iBAAgBI,UAAhB,CAA2BhB,UAAU,CAACK,WAAtC,CAAhB,CAFyC,CAIzC;;AACA,UAAMY,iBAAiB,mBACrBF,OADqB,aACrBA,OADqB,uBACrBA,OAAO,CAAEG,GAAT,CAAcC,MAAD,IAAaA,MAAD,CAA8BC,GAAvD,CADqB,uDAC0C,EADjE;AAEA,UAAMC,aAAqC,GAAG,EAC5C,GAAGV;AADyC,KAA9C;;AAGA,SAAK,MAAMS,GAAX,IAAkBH,iBAAlB,EAAqC;AACnC,UAAIG,GAAG,IAAIC,aAAX,EAA0B;AACxBA,QAAAA,aAAa,CAACD,GAAD,CAAb,GAAqB,KAArB;AACD;AACF,KAdwC,CAgBzC;;;AACA,UAAME,WAAW,GAAG,EAClB,GAAGZ,KADe;AAElBa,MAAAA,YAAY,EAAE,EACZ,GAAGF,aADS;AAEZ,YAAGX,KAAH,aAAGA,KAAH,uBAAGA,KAAK,CAAEa,YAAV;AAFY;AAFI,KAApB;AAOA,6BAAKX,SAAL,sEAAgBY,UAAhB,CAA2BF,WAA3B;AACA,WAAOA,WAAP;AACD;;AAEU,QAALG,KAAK,GAAG;AAAA;;AACZ,UAAMC,MAAM,gDAAG,KAAKd,SAAR,qDAAG,iBAAgBc,MAAhB,CAAuBZ,GAAvB,EAAH,yEAAmC,EAA/C;AACA,UAAMa,aAA+B,GAAG1B,KAAK,CAC3CyB,MAD2C,+CAE3C,KAAKd,SAFsC,qDAE3C,iBAAgBgB,SAAhB,GAA4BC,YAFe,yEAEC1B,oBAFD,CAA7C;AAKA,QAAI2B,UAAiB,GAAG,EAAxB;AACA,QAAIC,eAAe,GAAG,CAAtB;AAEA,UAAMC,OAAO,CAACC,GAAR,CACJN,aAAa,CAACT,GAAd,CAAkB,MAAOgB,KAAP,IAAiC;AACjD,UAAI;AAAA;;AACF,cAAMhC,UAAU,CAAC;AACfiC,UAAAA,MAAM,sBAAE,KAAKvB,SAAP,qDAAE,iBAAgBgB,SAAhB,EADO;AAEfF,UAAAA,MAAM,EAAEQ;AAFO,SAAD,CAAhB;AAIAJ,QAAAA,UAAU,GAAGA,UAAU,CAACM,MAAX,CAAkBF,KAAlB,CAAb;AACD,OAND,CAME,OAAOG,CAAP,EAAU;AACVC,QAAAA,OAAO,CAACC,IAAR,CAAaF,CAAb;AACAN,QAAAA,eAAe,IAAIG,KAAK,CAACM,MAAzB;AACD,OATD,SASU;AAAA;;AACR,iCAAK5B,SAAL,sEAAgB6B,YAAhB,CAA6BX,UAA7B;AACD;AACF,KAbD,CADI,CAAN;;AAiBA,QAAIA,UAAU,CAACU,MAAf,EAAuB;AAAA;;AACrB,8BAAI,KAAK5B,SAAT,6CAAI,iBAAgBgB,SAAhB,GAA4Bc,KAAhC,EAAuC;AACrCJ,QAAAA,OAAO,CAACK,IAAR,CAAc,QAAOb,UAAU,CAACU,MAAO,SAAvC;AACD;AACF;;AAED,QAAIT,eAAJ,EAAqB;AACnBO,MAAAA,OAAO,CAACM,KAAR,CAAe,kBAAiBb,eAAgB,UAAhD;AACD;AACF;;AA3EuD","sourcesContent":["import { DestinationPlugin } from '../plugin';\nimport {\n  PluginType,\n  SegmentAPIIntegrations,\n  SegmentAPISettings,\n  SegmentEvent,\n  UpdateType,\n} from '../types';\nimport { chunk } from '../util';\nimport { sendEvents } from '../api';\n\nconst MAX_EVENTS_PER_BATCH = 100;\n\nexport class SegmentDestination extends DestinationPlugin {\n  type = PluginType.destination;\n\n  key = 'Segment.io';\n\n  update(_: SegmentAPISettings, __: UpdateType) {\n    // this is where analytics-swift initalizes the HTTP client\n    // no need to do this for React Native where we just use the fetch polyfill directly\n    // see flush() below\n  }\n\n  execute(event: SegmentEvent): SegmentEvent {\n    const pluginSettings = this.analytics?.settings.get();\n    const plugins = this.analytics?.getPlugins(PluginType.destination);\n\n    // Disable all destinations that have a device mode plugin\n    const deviceModePlugins =\n      plugins?.map((plugin) => (plugin as DestinationPlugin).key) ?? [];\n    const cloudSettings: SegmentAPIIntegrations = {\n      ...pluginSettings,\n    };\n    for (const key of deviceModePlugins) {\n      if (key in cloudSettings) {\n        cloudSettings[key] = false;\n      }\n    }\n\n    // User/event defined integrations override the cloud/device mode merge\n    const mergedEvent = {\n      ...event,\n      integrations: {\n        ...cloudSettings,\n        ...event?.integrations,\n      },\n    };\n    this.analytics?.queueEvent(mergedEvent);\n    return mergedEvent;\n  }\n\n  async flush() {\n    const events = this.analytics?.events.get() ?? [];\n    const chunkedEvents: SegmentEvent[][] = chunk(\n      events,\n      this.analytics?.getConfig().maxBatchSize ?? MAX_EVENTS_PER_BATCH\n    );\n\n    let sentEvents: any[] = [];\n    let numFailedEvents = 0;\n\n    await Promise.all(\n      chunkedEvents.map(async (batch: SegmentEvent[]) => {\n        try {\n          await sendEvents({\n            config: this.analytics?.getConfig()!,\n            events: batch,\n          });\n          sentEvents = sentEvents.concat(batch);\n        } catch (e) {\n          console.warn(e);\n          numFailedEvents += batch.length;\n        } finally {\n          this.analytics?.removeEvents(sentEvents);\n        }\n      })\n    );\n\n    if (sentEvents.length) {\n      if (this.analytics?.getConfig().debug) {\n        console.info(`Sent ${sentEvents.length} events`);\n      }\n    }\n\n    if (numFailedEvents) {\n      console.error(`Failed to send ${numFailedEvents} events.`);\n    }\n  }\n}\n"]}